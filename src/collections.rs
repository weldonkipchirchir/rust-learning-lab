//  Vectors allow you to store more than one value in a single data structure that puts all the values next to each other in memory.
//Vectors can only store values of the same type.
// Rust conveniently provides the vec! macro, which will create a new vector that holds the values you give it.

use core::hash;
use std::vec;

pub fn collections() {
    creating_vector();
    reading_vector_elements();
    borrowing_transfer_mutability();
    iterate_vectors();
    enum_store_multiple_values();
    strings();
    hash_maps();
}

fn creating_vector() {
    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
}

fn reading_vector_elements() {
    let v = vec![1, 2, 3, 4, 5, 6];

    let third: &i32 = &v[2]; //When accessing elements from a vector in Rust, you typically have two options: either you can take ownership of the element or you can borrow it. In this case, using a reference (&i32) allows borrowing the element without transferring ownership.
    println!("The third element is {third}");

    let third: Option<&i32> = v.get(7);
    match third {
        Some(third) => println!("The third element is {third}"),
        None => println!("There is no third element."),
    }
}

fn borrowing_transfer_mutability() {
    let mut v1 = vec![1, 2, 3, 4, 5];

    let first = &mut v1[0];
    *first = 34; // we are dereferencing the mutable reference first to modify the value it refers to. In Rust, when you have a mutable reference, you need to use the dereference operator (*) to access and modify the value it points to. So, *first = 100; means "assign the value 100 to the memory location pointed to by first".

    println!("The first element is: {first}");

    let mut vector = vec![1, 2, 3];
    let mut_ref = &mut vector;
    mut_ref.push(9);

    // Accessing the last element using the `last()` method
    //The last() Method: The last() method is defined for slices (&[T]) and returns an Option<&T>, where T is the type of elements in the slice. It returns Some(&last_element)
    if let Some(last_element) = mut_ref.last() {
        println!("The last element is: {}", last_element);
    } else {
        println!("The vector is empty");
    }
}

fn iterate_vectors() {
    let v1 = vec![100, 32, 57];
    for i in &v1 {
        println!("{i}");
    }

    let mut v2 = vec![23, 45, 21, 19];
    for i in &mut v2 {
        let result = *i * 50;
        println!("The result is {} ", result);
    }
}

#[derive(Debug)]
enum SpreadSheetCell{
    Int(i32),
    FLoat(f64),
    Text(String),
}
fn enum_store_multiple_values(){
    let row = vec![
        SpreadSheetCell::Int(3),
        SpreadSheetCell::Text(String::from("blue")),
        SpreadSheetCell::FLoat(10.47),
    ];

    println!("Enum with vector {:?}", row);
}

fn strings(){
    let data = "initial strings";
    let s = data.to_string();

    //creating a string from string literal
    let ss = String::from("Initial contents");

    //updating a string
    let mut s = String::from("foo");
    s.push_str("bar\t"); //adds string slice
    s.push('l'); // single char
    println!("updated string : {}", s);

    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &s2; // note s1 has been moved here and can no longer be used

        let s1 = String::from("tic");
        let s2 = String::from("tac");
        let s3 = String::from("toe");
    
        let s = s1 + "-" + &s2 + "-" + &s3;

        let st = String::from("tic");
        let s2 = String::from("tac");
        let s3 = String::from("toe");

        let s2 = format!("{st}-{s2}-{s3}"); //format! is much easier to read, and the code generated by the format! macro uses references so that this call doesn’t take ownership of any of its parameters.

        for c in s2.chars() {
            println!("{c}")
        }
}


use std::collections::HashMap;
fn hash_maps(){
    // The type HashMap<K, V> stores a mapping of keys of type K to values of type V using a hashing function, which determines how it places these keys and values into memory. 
    // Like vectors, hash maps are homogeneous: all of the keys must have the same type as each other, and all of the values must have the same type.
    // creating a new hash map
    let mut scores = HashMap::new(); //create empty hash map

    scores.insert(String::from("Blues"), 10);
    scores.insert(String::from("Yellow"), 50);

    //accessing values in a Hash Map
    let team_name = String::from("Blue");
    //The get method returns an Option<&V>; if there’s no value for that key in the hash map, get will return None. This program handles the Option by calling copied to get an Option<i32> rather than an Option<&i32>, then unwrap_or to set score to zero if scores doesn't have an entry for the key.
    let score = scores.get(&team_name).copied().unwrap_or(0);
    println!("score is {score}");

    for (key, value) in &scores{
        println!("{key}: {value}");
    }

    let text = "hello world wonderful world";

    let mut map = HashMap::new();

    for word in text.split_whitespace(){
        //The or_insert method returns a mutable reference (&mut V) to the value for the specified key. Here we store that mutable reference in the count variable, so in order to assign to that value, we must first dereference count using the asterisk (*). The mutable reference goes out of scope at the end of the for loop, so all of these changes are safe and allowed by the borrowing rules.
        let count = map.entry(word).or_insert(0);
        *count +=1;
    }
    println!("{:?}", map);
}
